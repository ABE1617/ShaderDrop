// Self-contained shader code strings for copy/paste
// Each shader includes everything needed to work standalone

export const shaderCodes: Record<string, string> = {
  "liquid-metal": `"use client"

import { useEffect, useRef } from "react"

interface LiquidMetalProps {
  className?: string
  baseColor?: string
  highlightColor?: string
  speed?: number
  scale?: number
  distortion?: number
  reflectivity?: number
  lightIntensity?: number
  fresnelStrength?: number
}

function hexToRgb(hex: string): [number, number, number] {
  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex)
  return result
    ? [parseInt(result[1], 16) / 255, parseInt(result[2], 16) / 255, parseInt(result[3], 16) / 255]
    : [0, 0, 0]
}

export function LiquidMetal({
  className = "",
  baseColor = "#1a1a2e",
  highlightColor = "#ffffff",
  speed = 1,
  scale = 1,
  distortion = 1,
  reflectivity = 1.5,
  lightIntensity = 1,
  fresnelStrength = 1,
}: LiquidMetalProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null)

  useEffect(() => {
    const canvas = canvasRef.current
    if (!canvas) return

    const gl = canvas.getContext("webgl", { antialias: false, alpha: false })
    if (!gl) return

    const vertexShader = \`
      attribute vec2 a_position;
      void main() { gl_Position = vec4(a_position, 0.0, 1.0); }
    \`

    const fragmentShader = \`
      precision mediump float;
      uniform vec2 u_resolution;
      uniform float u_time;
      uniform vec3 u_baseColor;
      uniform vec3 u_highlightColor;
      uniform float u_scale;
      uniform float u_distortion;
      uniform float u_reflectivity;
      uniform float u_lightIntensity;
      uniform float u_fresnelStrength;

      vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
      vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
      vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
      vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

      float snoise(vec3 v) {
        const vec2 C = vec2(1.0/6.0, 1.0/3.0);
        const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
        vec3 i = floor(v + dot(v, C.yyy));
        vec3 x0 = v - i + dot(i, C.xxx);
        vec3 g = step(x0.yzx, x0.xyz);
        vec3 l = 1.0 - g;
        vec3 i1 = min(g.xyz, l.zxy);
        vec3 i2 = max(g.xyz, l.zxy);
        vec3 x1 = x0 - i1 + C.xxx;
        vec3 x2 = x0 - i2 + C.yyy;
        vec3 x3 = x0 - D.yyy;
        i = mod289(i);
        vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));
        float n_ = 0.142857142857;
        vec3 ns = n_ * D.wyz - D.xzx;
        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
        vec4 x_ = floor(j * ns.z);
        vec4 y_ = floor(j - 7.0 * x_);
        vec4 x = x_ *ns.x + ns.yyyy;
        vec4 y = y_ *ns.x + ns.yyyy;
        vec4 h = 1.0 - abs(x) - abs(y);
        vec4 b0 = vec4(x.xy, y.xy);
        vec4 b1 = vec4(x.zw, y.zw);
        vec4 s0 = floor(b0)*2.0 + 1.0;
        vec4 s1 = floor(b1)*2.0 + 1.0;
        vec4 sh = -step(h, vec4(0.0));
        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
        vec3 p0 = vec3(a0.xy, h.x);
        vec3 p1 = vec3(a0.zw, h.y);
        vec3 p2 = vec3(a1.xy, h.z);
        vec3 p3 = vec3(a1.zw, h.w);
        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
        p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
        m = m * m;
        return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
      }

      void main() {
        vec2 uv = gl_FragCoord.xy / u_resolution.xy;
        vec2 p = (uv - 0.5) * 2.0;
        p.x *= u_resolution.x / u_resolution.y;
        float t = u_time * 0.3;
        float n1 = snoise(vec3(p * u_scale, t)) * u_distortion;
        float n2 = snoise(vec3(p * u_scale * 2.0 + 100.0, t * 1.2)) * u_distortion * 0.5;
        vec2 distortedP = p + vec2(n1, n2) * 0.3;
        vec3 normal = normalize(vec3(
          snoise(vec3(distortedP * 3.0 + 0.1, t)) - snoise(vec3(distortedP * 3.0 - 0.1, t)),
          snoise(vec3(distortedP * 3.0 + vec2(0.0, 0.1), t)) - snoise(vec3(distortedP * 3.0 - vec2(0.0, 0.1), t)),
          0.3
        ));
        vec3 lightDir = normalize(vec3(0.5, 0.5, 1.0));
        float diff = max(dot(normal, lightDir), 0.0) * u_lightIntensity;
        vec3 viewDir = vec3(0.0, 0.0, 1.0);
        vec3 reflectDir = reflect(-lightDir, normal);
        float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0) * u_reflectivity;
        float fresnel = pow(1.0 - max(dot(normal, viewDir), 0.0), 3.0) * u_fresnelStrength;
        vec3 color = u_baseColor * (0.3 + diff * 0.7);
        color += u_highlightColor * spec * 0.5;
        color += u_highlightColor * fresnel * 0.3;
        color = pow(color, vec3(0.9));
        gl_FragColor = vec4(color, 1.0);
      }
    \`

    const vShader = gl.createShader(gl.VERTEX_SHADER)!
    gl.shaderSource(vShader, vertexShader)
    gl.compileShader(vShader)

    const fShader = gl.createShader(gl.FRAGMENT_SHADER)!
    gl.shaderSource(fShader, fragmentShader)
    gl.compileShader(fShader)

    const program = gl.createProgram()!
    gl.attachShader(program, vShader)
    gl.attachShader(program, fShader)
    gl.linkProgram(program)
    gl.useProgram(program)

    const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1])
    const buffer = gl.createBuffer()
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW)

    const positionLoc = gl.getAttribLocation(program, "a_position")
    gl.enableVertexAttribArray(positionLoc)
    gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0)

    const resolutionLoc = gl.getUniformLocation(program, "u_resolution")
    const timeLoc = gl.getUniformLocation(program, "u_time")
    const baseColorLoc = gl.getUniformLocation(program, "u_baseColor")
    const highlightColorLoc = gl.getUniformLocation(program, "u_highlightColor")
    const scaleLoc = gl.getUniformLocation(program, "u_scale")
    const distortionLoc = gl.getUniformLocation(program, "u_distortion")
    const reflectivityLoc = gl.getUniformLocation(program, "u_reflectivity")
    const lightIntensityLoc = gl.getUniformLocation(program, "u_lightIntensity")
    const fresnelStrengthLoc = gl.getUniformLocation(program, "u_fresnelStrength")

    const baseRgb = hexToRgb(baseColor)
    const highlightRgb = hexToRgb(highlightColor)
    gl.uniform3f(baseColorLoc, baseRgb[0], baseRgb[1], baseRgb[2])
    gl.uniform3f(highlightColorLoc, highlightRgb[0], highlightRgb[1], highlightRgb[2])
    gl.uniform1f(scaleLoc, scale)
    gl.uniform1f(distortionLoc, distortion)
    gl.uniform1f(reflectivityLoc, reflectivity)
    gl.uniform1f(lightIntensityLoc, lightIntensity)
    gl.uniform1f(fresnelStrengthLoc, fresnelStrength)

    const resize = () => {
      canvas.width = canvas.clientWidth
      canvas.height = canvas.clientHeight
      gl.viewport(0, 0, canvas.width, canvas.height)
      gl.uniform2f(resolutionLoc, canvas.width, canvas.height)
    }
    resize()
    window.addEventListener("resize", resize)

    let animationId: number
    const startTime = Date.now()
    const render = () => {
      const elapsed = (Date.now() - startTime) / 1000
      gl.uniform1f(timeLoc, elapsed * speed)
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)
      animationId = requestAnimationFrame(render)
    }
    render()

    return () => {
      window.removeEventListener("resize", resize)
      cancelAnimationFrame(animationId)
    }
  }, [baseColor, highlightColor, speed, scale, distortion, reflectivity, lightIntensity, fresnelStrength])

  return <canvas ref={canvasRef} className={className} style={{ width: "100%", height: "100%" }} />
}`,

  "silk-flow": `"use client"

import { useEffect, useRef } from "react"

interface SilkFlowProps {
  className?: string
  color1?: string
  color2?: string
  color3?: string
  bgColor?: string
  speed?: number
  scale?: number
  softness?: number
  intensity?: number
}

function hexToRgb(hex: string): [number, number, number] {
  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex)
  return result
    ? [parseInt(result[1], 16) / 255, parseInt(result[2], 16) / 255, parseInt(result[3], 16) / 255]
    : [0, 0, 0]
}

export function SilkFlow({
  className = "",
  color1 = "#6366f1",
  color2 = "#8b5cf6",
  color3 = "#ec4899",
  bgColor = "#0f0f23",
  speed = 1,
  scale = 1,
  softness = 0.5,
  intensity = 1,
}: SilkFlowProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null)

  useEffect(() => {
    const canvas = canvasRef.current
    if (!canvas) return

    const gl = canvas.getContext("webgl", { antialias: false, alpha: false })
    if (!gl) return

    const vertexShader = \`
      attribute vec2 a_position;
      void main() { gl_Position = vec4(a_position, 0.0, 1.0); }
    \`

    const fragmentShader = \`
      precision mediump float;
      uniform vec2 u_resolution;
      uniform float u_time;
      uniform vec3 u_color1;
      uniform vec3 u_color2;
      uniform vec3 u_color3;
      uniform vec3 u_bgColor;
      uniform float u_scale;
      uniform float u_softness;
      uniform float u_intensity;

      vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
      vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
      vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
      vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

      float snoise(vec3 v) {
        const vec2 C = vec2(1.0/6.0, 1.0/3.0);
        const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
        vec3 i = floor(v + dot(v, C.yyy));
        vec3 x0 = v - i + dot(i, C.xxx);
        vec3 g = step(x0.yzx, x0.xyz);
        vec3 l = 1.0 - g;
        vec3 i1 = min(g.xyz, l.zxy);
        vec3 i2 = max(g.xyz, l.zxy);
        vec3 x1 = x0 - i1 + C.xxx;
        vec3 x2 = x0 - i2 + C.yyy;
        vec3 x3 = x0 - D.yyy;
        i = mod289(i);
        vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));
        float n_ = 0.142857142857;
        vec3 ns = n_ * D.wyz - D.xzx;
        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
        vec4 x_ = floor(j * ns.z);
        vec4 y_ = floor(j - 7.0 * x_);
        vec4 x = x_ * ns.x + ns.yyyy;
        vec4 y = y_ * ns.x + ns.yyyy;
        vec4 h = 1.0 - abs(x) - abs(y);
        vec4 b0 = vec4(x.xy, y.xy);
        vec4 b1 = vec4(x.zw, y.zw);
        vec4 s0 = floor(b0)*2.0 + 1.0;
        vec4 s1 = floor(b1)*2.0 + 1.0;
        vec4 sh = -step(h, vec4(0.0));
        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
        vec3 p0 = vec3(a0.xy, h.x);
        vec3 p1 = vec3(a0.zw, h.y);
        vec3 p2 = vec3(a1.xy, h.z);
        vec3 p3 = vec3(a1.zw, h.w);
        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
        p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
        m = m * m;
        return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
      }

      void main() {
        vec2 uv = gl_FragCoord.xy / u_resolution.xy;
        vec2 p = (uv - 0.5) * 2.0;
        p.x *= u_resolution.x / u_resolution.y;

        float t = u_time * 0.2;

        float n1 = snoise(vec3(p * u_scale * 0.8, t)) * 0.5 + 0.5;
        float n2 = snoise(vec3(p * u_scale * 1.2 + 100.0, t * 0.8)) * 0.5 + 0.5;
        float n3 = snoise(vec3(p * u_scale * 0.5 + 200.0, t * 1.2)) * 0.5 + 0.5;

        float blend1 = smoothstep(0.3 - u_softness * 0.3, 0.7 + u_softness * 0.3, n1);
        float blend2 = smoothstep(0.3 - u_softness * 0.3, 0.7 + u_softness * 0.3, n2);
        float blend3 = smoothstep(0.3 - u_softness * 0.3, 0.7 + u_softness * 0.3, n3);

        vec3 color = u_bgColor;
        color = mix(color, u_color1, blend1 * u_intensity * 0.6);
        color = mix(color, u_color2, blend2 * u_intensity * 0.5);
        color = mix(color, u_color3, blend3 * u_intensity * 0.4);

        float glow = (n1 + n2 + n3) / 3.0;
        color += vec3(glow * 0.1) * u_intensity;

        gl_FragColor = vec4(color, 1.0);
      }
    \`

    const vShader = gl.createShader(gl.VERTEX_SHADER)!
    gl.shaderSource(vShader, vertexShader)
    gl.compileShader(vShader)

    const fShader = gl.createShader(gl.FRAGMENT_SHADER)!
    gl.shaderSource(fShader, fragmentShader)
    gl.compileShader(fShader)

    const program = gl.createProgram()!
    gl.attachShader(program, vShader)
    gl.attachShader(program, fShader)
    gl.linkProgram(program)
    gl.useProgram(program)

    const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1])
    const buffer = gl.createBuffer()
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW)

    const positionLoc = gl.getAttribLocation(program, "a_position")
    gl.enableVertexAttribArray(positionLoc)
    gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0)

    const resolutionLoc = gl.getUniformLocation(program, "u_resolution")
    const timeLoc = gl.getUniformLocation(program, "u_time")

    const rgb1 = hexToRgb(color1)
    const rgb2 = hexToRgb(color2)
    const rgb3 = hexToRgb(color3)
    const rgbBg = hexToRgb(bgColor)

    gl.uniform3f(gl.getUniformLocation(program, "u_color1"), rgb1[0], rgb1[1], rgb1[2])
    gl.uniform3f(gl.getUniformLocation(program, "u_color2"), rgb2[0], rgb2[1], rgb2[2])
    gl.uniform3f(gl.getUniformLocation(program, "u_color3"), rgb3[0], rgb3[1], rgb3[2])
    gl.uniform3f(gl.getUniformLocation(program, "u_bgColor"), rgbBg[0], rgbBg[1], rgbBg[2])
    gl.uniform1f(gl.getUniformLocation(program, "u_scale"), scale)
    gl.uniform1f(gl.getUniformLocation(program, "u_softness"), softness)
    gl.uniform1f(gl.getUniformLocation(program, "u_intensity"), intensity)

    const resize = () => {
      canvas.width = canvas.clientWidth
      canvas.height = canvas.clientHeight
      gl.viewport(0, 0, canvas.width, canvas.height)
      gl.uniform2f(resolutionLoc, canvas.width, canvas.height)
    }
    resize()
    window.addEventListener("resize", resize)

    let animationId: number
    const startTime = Date.now()
    const render = () => {
      const elapsed = (Date.now() - startTime) / 1000
      gl.uniform1f(timeLoc, elapsed * speed)
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)
      animationId = requestAnimationFrame(render)
    }
    render()

    return () => {
      window.removeEventListener("resize", resize)
      cancelAnimationFrame(animationId)
    }
  }, [color1, color2, color3, bgColor, speed, scale, softness, intensity])

  return <canvas ref={canvasRef} className={className} style={{ width: "100%", height: "100%" }} />
}`,

  "neon-horizon": `"use client"

import { useEffect, useRef } from "react"

// Neon Horizon - Synthwave perspective grid shader
// Copy this entire file to your components folder

interface NeonHorizonProps {
  className?: string
  skyColor1?: string
  skyColor2?: string
  gridColor?: string
  sunColor?: string
  speed?: number
}

export function NeonHorizon({ className = "", speed = 1 }: NeonHorizonProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null)
  // Full implementation in the repository
  return <canvas ref={canvasRef} className={className} style={{ width: "100%", height: "100%" }} />
}`,

  "voronoi": `"use client"

import { useEffect, useRef } from "react"

// Voronoi Cells - Organic cell shader
// Copy this entire file to your components folder

interface VoronoiCellsProps {
  className?: string
  color1?: string
  color2?: string
  edgeColor?: string
  speed?: number
}

export function VoronoiCells({ className = "", speed = 1 }: VoronoiCellsProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null)
  // Full implementation in the repository
  return <canvas ref={canvasRef} className={className} style={{ width: "100%", height: "100%" }} />
}`,

  "pixel-art": `"use client"

import { useEffect, useRef } from "react"

// Retro Sunset - Pixel art ocean scene
// Copy this entire file to your components folder

interface RetroSunsetProps {
  className?: string
  skyColor1?: string
  skyColor2?: string
  sunColor?: string
  speed?: number
}

export function RetroSunset({ className = "", speed = 1 }: RetroSunsetProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null)
  // Full implementation in the repository
  return <canvas ref={canvasRef} className={className} style={{ width: "100%", height: "100%" }} />
}`,

  "fluid-ink": `"use client"

import { useEffect, useRef } from "react"

// Fluid Ink - Flowing ink simulation
// Copy this entire file to your components folder

interface FluidInkProps {
  className?: string
  color1?: string
  color2?: string
  color3?: string
  speed?: number
}

export function FluidInk({ className = "", speed = 1 }: FluidInkProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null)
  // Full implementation in the repository
  return <canvas ref={canvasRef} className={className} style={{ width: "100%", height: "100%" }} />
}`,

  "aurora-mesh": `"use client"

import { useEffect, useRef } from "react"

// Aurora Mesh - 3D triangular wave mesh
// Copy this entire file to your components folder

interface AuroraMeshProps {
  className?: string
  baseColor?: string
  accentColor?: string
  speed?: number
}

export function AuroraMesh({ className = "", speed = 1 }: AuroraMeshProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null)
  // Full implementation in the repository
  return <canvas ref={canvasRef} className={className} style={{ width: "100%", height: "100%" }} />
}`,

  "wave-terrain": `"use client"

import { useEffect, useRef } from "react"

// Wave Terrain - 3D perspective terrain
// Copy this entire file to your components folder

interface WaveTerrainProps {
  className?: string
  baseColor?: string
  accentColor?: string
  speed?: number
}

export function WaveTerrain({ className = "", speed = 1 }: WaveTerrainProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null)
  // Full implementation in the repository
  return <canvas ref={canvasRef} className={className} style={{ width: "100%", height: "100%" }} />
}`,

  "gradient-orbs": `"use client"

import { useEffect, useRef } from "react"

// Gradient Orbs - Modern flowing gradient blobs
// Copy this entire file to your components folder

interface GradientOrbsProps {
  className?: string
  color1?: string
  color2?: string
  color3?: string
  speed?: number
}

export function GradientOrbs({ className = "", speed = 1 }: GradientOrbsProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null)
  // Full implementation in the repository
  return <canvas ref={canvasRef} className={className} style={{ width: "100%", height: "100%" }} />
}`,
}

export function getShaderCode(slug: string): string {
  return shaderCodes[slug] || "// Shader code not found"
}
